\section{Conclusion}\label{sec:conclusion}

The technique presented in this paper allows a simple
specification of a deterministic fragment of the Java library and a simple
technique for enforcing run-time constraints on values.
The technique is general, although we have focused on the
relevant issue of avoiding \<Object.hashCode()> non-determinism.
For that special case, it could be possible to patch the Java library
with an implementation of \<Object.hashCode()> that constantly and
deterministically yields a constant. That would work for that run-time condition
only and would be invasive (all blockchain nodes should use a patched,
unofficial version of the Java library). It would lead to very inefficient
code if objects are put in hashsets without redefining their \<hashCode()>.
Our solution rejects the smart contract in that case, statically or dynamically.

Our specification and verification technique does not help with the
identification of deterministic fragments of the Java library. Currently,
we have checked the source code of the library to convince ourselves that,
for instance, the fragment in Figs.~\ref{fig:white_listed_Object}, \ref{fig:white_listed_Collection},
\ref{fig:white_listed_Set}, \ref{fig:white_listed_List},
\ref{fig:white_listed_HashSet} and \ref{fig:white_listed_ArrayList} is deterministic.
Static analysis could help here, if it could prove some fragment deterministic,
automatically. But the complexity of the library code and the use of native code
seem to make this task very hard.
