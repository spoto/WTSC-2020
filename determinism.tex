\section{Determinism for Java Methods in Smart Contracts}\label{sec:determinism}

This section discusses the different kinds of determinism of methods from
the Java library and what must be required if such methods are used
in a language for smart contracts.
We recall that the Java library exists in different versions, from its first
$1.0$ edition of 1996 to its $13$ edition expected to ship in September 2019.
Each version has different implementations, with OpenJDK probably being
the most used, nowadays. Some classes and methods exist only in some versions of the library.
For instance, class \<java.lang.Integer> exists from the very first $1.0$ edition,
while class \<java.util.Collection> was introduced in version $1.2$.
In the following, when discussing a specific methods, we assume that a version
of the Java library is used, where the class and the same method exist.
Moreover, we report fully qualified names of classes only the first time they are cited.

Fig.~\ref{fig:determinism} reports some examples of methods
from the Java library, classified
on the basis of the kind of determinism that holds for them.
We discuss them below. Since Java is an object-oriented language,
a non-static method can always be called on any object whose class
is a subtype of that where the method is defined. For instance, method \<Number.intValue()> in
Fig.~\ref{fig:determinism} can be called on any object that extends
\<java.lang.Number> and that call, at run time, might
execute any implementation of \<intValue()> in any subtype of \<Number>
(such as in \<java.lang.Integer> or in \<java.lang.Double>).
Hence, when Fig.~\ref{fig:determinism} classifies \<Number.intValue()> as always
deterministic, this means that that is true for every implementation of
\<intValue()> in the subtypes of \<Number> of the Java library.

Many methods of the Java library are clearly deterministic. Their behavior is fixed
and does not change with distinct versions of the library. An example is the unwrapping
method \<intValue()> of \<Number> (Fig.~\ref{fig:determinism}). It yields
the primitive \<int> value corresponding to any object of the abstract class \<Number>.
Examples are objects of class \<java.lang.Integer> or \<java.lang.Double>. For instance,
\[
\<new Integer(3).intValue() == 3>
\]
holds in any version of the Java library, as well as
\[
\<new Double(3.14).intValue() == 3>
\]
since truncation of \<double> into \<int> is machine-independent in Java.
Hence, a language for smart contracts, that must require determinism,
can safely allow the use of that method, always.

\begin{figure}[t]
  \begin{center}
    \begin{tabular}{|l||C{1cm}|C{1.25cm}|C{1.57cm}|C{1cm}|}
      \hline
      \multicolumn{1}{|c||}{\multirow{3}{*}{\textbf{Method}}} & \multicolumn{4}{ c| }{\textbf{Deterministic?}}\\\cline{2-5}
      & \multirow{2}{*}{always} & \multirow{2}{*}{platform} & platform + & \multirow{2}{*}{never} \\
      & & & conditions & \\\hline\hline
      \<Number.intValue()> & \checkmark &   &   & \\\hline
      \<Integer.valueOf(int i)> & & \checkmark & & \\\hline
      \<System.currentTimeMillis()> & & & & \checkmark \\\hline
      \<BaseStream$\text{<}$T,S$\text{>}$.parallel()> & & & & \checkmark \\\hline
      \<Object.hashCode()> & & & \checkmark & \\\hline
      \<Object.toString()> & & & \checkmark & \\\hline
      \<Collection$\text{<}$E$\text{>}$.iterator()> & & & \checkmark & \\\hline
      \<Collection$\text{<}$E$\text{>}$.stream()> & & & \checkmark & \\\hline
      \<Collection$\text{<}$E$\text{>}$.add(E e)> & & & \checkmark & \\\hline
      \<StreamSupport.stream(Spliterator$\text{<}$T$\text{>}$ s, boolean p)> & & & \checkmark & \\\hline
      \multicolumn{1}{c}{} & \multicolumn{3}{c}{\upbracefill}\\
      \multicolumn{1}{c}{} & \multicolumn{3}{c}{white-listed}\\
    \end{tabular}
  \end{center}
  \caption{Some methods of the Java library, with their behavior \emph{wrt.} code determinism.
\emph{Always} means that a method does not compromise code determinism.
\emph{Platform} means that
a method does not compromise determinism, but only once a specific implementation
of the library is fixed. \emph{Platform + conditions} means that a method
does not compromise determinism, but only if an implementation of the library is fixed
\emph{and} the program satisfies extra conditions, that typically refer to
the actual arguments passed to the method at run time or to if and how
other methods are called. \emph{Never} means
that a method can have different behaviors in distinct executions,
even after fixing the library implementation of the actual arguments, and no
condition can be sensibly devised to guarantee that it does not compromise code
determinism.}\label{fig:determinism}
\end{figure}

Consider the static method \<Integer.valueOf(int i)> now. It performs the inverse operation of wrapping
a primitive \<int> value into an object of class \<Integer>. It might be surprising, but its behavior
can be different in distinct implementations of the Java library. For instance,
\[
\<Integer.valueOf(3) == Integer.valueOf(3)>
\]
holds, in every implementation of the library, since the official documentation requires this method
to cache values between $-128$ and $127$, inclusive. But there is no guarantee that caching is
used outside that range, so that
\[
\<Integer.valueOf(2019) == Integer.valueOf(2019)>
\]
might be true in some implementations and false in others, that yield distinct objects for the two calls.
We call \emph{platform deterministic} such methods, since they are deterministic only once a specific
implementation (\emph{platform}) of the Java library is fixed. Such methods can be used in smart contracts,
but the requirement that nodes use a specific version of the Java library must be included
in the consensus rules.

Consider the static method \<System.currentTimeMillis()> of \<java.lang.System>.
It yields the number of milliseconds elapsed since the beginning of 1970.
Not surprisingly, code using that method will get diffrent measures for distinct calls.
Such inherently non-deterministic methods cannot be accepted in a smart contract.
Method \<parallel()> of the \<java.util.stream.BaseStream> class, instead,
yields a parallel version of a stream. Introduced in Java 8, streams are
an abstract description of a lazy enumeration algorithm over values.
They are meant to implement the map/reduce design pattern. Their specification
makes heavy use of lamba expressions. For instance, consider following code
%
\begin{verbatim}
List<Integer> list = ...
int positive = list.stream().parallel()
  .mapToInt(Integer::intValue)
  .filter(i -> i > 0)
  .findAny()
  .getAsInt();
\end{verbatim}
%
and assume that \<list> contains at least a positive \<Integer>.
The code above processes \<list> by defining a parallel algorithm
that unwraps each element into its corresponding \<int> primitive value,
filters only the positive values and then selects any of them.
The result of \<findAny()> is an optional value, hence the
\<getAsInt()> call is needed at the end. Since the algorithm is
parallel, each execution of the code might select a different
positive element, depending on thread scheduling. Hence, \<parallel()>
cannot be allowed in a smart contract. Note that the same gas consumption
of the code is not deterministic, since it depends on how many elements
are checked before a thread is executed on a positive value, which terminates
the look-up.

Consider method \<Object.hashCode()> of \<java.lang.Object>. It yields an \<int>
hash of the object. In its current implementation, it computes it from the
RAM address of the object. Hence, different executions of the same call
will likely yield different hashes. The same occurs for method \<Object.toString()>,
that is implemented in terms of \<Object.hashCode()>: in OpenJDK 11, its
implementation concatenates the class name of the object with its hash:
%
\begin{verbatim}
public String toString() {
  return getClass().getName() + "@"
         + Integer.toHexString(hashCode());
}
\end{verbatim}
%
Banning such calls from smart contracts would, however, be overkill
and hardly accepted by programmers, that
heavily call such methods in their programs, without incurring in
non-determinism. The reason is that programmers very often
take care of calling such methods only on objects that redefine
\<hashCode()> or \<toString()>. If that is the case, the call will actually
execute the redefinition, that might well be deterministic. It seems sensible
to allow calls to such methods in smart contracts, but only if they occur
on objects that redefine them in a determinitsic way. Sec.~\ref{sec:proof_obligations}
shows how this extra condition can be enforced.
