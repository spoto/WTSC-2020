\section{Enforcing Proof-Obligations}\label{sec:enforcing}

Sec.~\ref{sec:white_listing} shows that a deterministic fragment of the Java library
can be specified by using run-time conditions on the values of the receiver or
parameters of a method. A blockchain node must enforce that such conditions hold
at run time for the smart contracts that it executes. This translates each condition
into a proof-obligation that must be discharged: if this is not possible, the smart contract
cannot be executed or, at least, its execution must be aborted. This section shows how
this is possible. The idea is that the code of the smart contract goes through a
preliminary instrumentation, only the first time it is installed in blockchain.
Very likely, ablockchain node receives
the smart cotract code in Java bytecode format, already compiled.
However, to make the technique more accessible to the reader, this section presents
the instrumentation at source-code level: it must be understood that it actually
works at bytecode-level, in practice.

Assume that a blockchain node verifies that smart contracts obey to the deterministic
fragment in Figs.~\ref{fig:white_listed_Object}, \ref{fig:white_listed_Collection},
\ref{fig:white_listed_Set}, \ref{fig:white_listed_List},
\ref{fig:white_listed_HashSet} and \ref{fig:white_listed_ArrayList}.
Assume that a user of the blockchain wants to install in blockchain a smart contract whose
code contains a call \<collection.remove(element)> whose signature is
\<Collection$\text{<}$E$\text{>}$.remove(Object o)>.
The blockchain node spots this syntactically.\footnote{The Java bytecode of the
  smart contract will
  contain an instruction \<invokeinterface java.util.Collection.remove(Object):boolean>,
  or a similar one for a subtype of \<Collection>.}
The blockchain node consults its white-listed fragment (Fig.~\ref{fig:white_listed_Collection})
and recognizes the call as
white-listed, but having a run-time constraint \<@MustRedefineHashCode> on \<o>. Hence, it
adds a brand new method to the code of the smart contract:
%
\begin{verbatim}
private static boolean verifier_0(Collection<E> receiver, Object par_0) {
  Support.mustRedefineHashCode(par_0);
  return receiver.remove(par_0);
}
\end{verbatim}
%
and replaces \<collection.remove(element)> with \<verifier\_0(collection, element)>.
At run-time, each time that code is executed, method
\<Support.mustRedefineHashCode(par\_0)> will check that the actual argument
passed to \<remove(Object o)> actually redefines \<hashCode()>. The node includes a
\<Support> class for this, that uses Java reflection to that purpose:
%
\begin{verbatim}
class Support {
  public static void mustRedefineHashCode(Object value) {
    if (value != null)
      if (Stream.of(value.getClass().getMethods())
          .filter(method -> !Modifier.isAbstract(method.getModifiers())
                         && Modifier.isPublic(method.getModifiers())
                         && method.getDeclaringClass() != Object.class)
          .map(Method::getName)
          .noneMatch("hashCode"::equals)) {
        // abort the current transaction and undo all its side-effects
      }
  }
}
\end{verbatim}
%
The code above\footnote{This is code in the blockchain node, not in a smart contract:
  any method can be used here; there is no white-listing notion for it.}
checks if the value is non-\<null> and has no method
named \<hashCode>
(possibly inherited) that is public, non-abstract and not declared in \<Object>.
If that is the case, then the value does not redefine \<hashCode()> from \<Object>
and the transaction gets aborted.

For another example, assume that the code of the smart contract
contains a call \<x.toString()> whose signature is
\<Object.toString()>.
Again, the blockchain node spots this syntactically,
consults its white-listed fragment (Fig.~\ref{fig:white_listed_Object}),
recognizes the call as
white-listed, but having a run-time constraint \<@MustRedefineHashCodeOrToString> on
the receiver of the call, and consequently
adds a brand new method to the code of the smart contract:
%
\begin{verbatim}
private static verifier_1(Object receiver) {
  Support.mustRedefineHashCodeOrToString(receiver);
  return receiver.toString();
}
\end{verbatim}
%
Then it replaces \<x.toString()> with \<verifier\_1(x)>.
Method \<Support.mustRedefineHashCodeOrToString(receiver)> is defined
similarly to the previous example.

Assume that the smart contract contains a static call
\<StreamSupport.stream(s, p)>, whose signature is
\<StreamSupport.stream(Spliterator$\text{<}$T$\text{>}$ s, boolean p)>,
and that the white-listed fragment of the blockchain node allows that signature,
but has a run-time condition on \<p> that avoids the creation of parallel streams:
\<StreamSupport.stream(Spliterator$\text{<}$T$\text{>}$ s, @MustBeFalse boolean p)>.
The node adds
a brand new method to the code of the smart contract:
%
\begin{verbatim}
private static Stream<T> verifier_2
    (Spliterator<T> par_0, boolean par_1) {
  Support.mustBeFalse(par_1);
  return StreamSupport.stream(par_0, par_1);
}
\end{verbatim}
%
Then it replaces \<StreamSupport.stream(s, p)> with \<verifier\_2(s, p)>.
Method \<Support.mustBeFalse(value)> is defined in class \<Support> as:
%
\begin{verbatim}
public static void mustBeFalse(boolean value) {
  if (value) {
    // abort the current transaction and undo all its side-effects
  }
}
\end{verbatim}

Obviously, the name of the verification methods (\<verifier\_0>, \<verifier\_1> and so on)
must be chosen in such a way to avoid name clashes with that of methods that might
have already existed in the smart contract. Moreover, if a call occurs more times
in the smart contract, it is more efficient to share the same verifier for all
occurrences, to keep the class file smaller.

We have implemented this technique at bytecode level, by using the BCEL
library for bytecode manipulation~\cite{bcel}. The cost of instrumentation never exceeds one
second on our machine.

\subsection{Static vs.\ Dynamic}\label{subsec:static_vs_dynamic}

The instrumentation technique described above adds dynamic checks on run-time values, to see
if they satisfy the run-time conditions required by a white-listed fragment.
Hence, the check is performed repeatedly, every time an annotated white-listed method
is executed. This can incur in a performance penalty. Hence it would be desirable
to check if a run-time condition holds, definitely, every time a call is executed.
This can be done with static analysis~\cite{NielsonNH99}, a technique for inferring
properties of a program, before it is actually run. Since the verification of
non-trivial run-time
properties of programs is in general undecidable~\cite{Rice53},
static analysis provides a definite answer
only in some cases. Hence, a blockchain node can apply static analysis to discharge
the proof-obligations due to run-time conditions on white-listed methods. If static
analysis succeeds with a definite answer, stating that a given condition definitely holds,
the blockchain node needn't generate any \<verifier> method for that condition. Otherwise, it
generates the \<verifier> method, as last resort.

Static analysis can be more or less aggressive.
More aggressive static analyses can discharge more proof-obligations statically,
which is desirable since the code of the smart contract will check less
conditions at run-time. However, aggressive analyses are typically more expensive
(although they are executed only once, when the smart contract is firstly installed in
blockchain). In practice, a good trade-off should be found between the power of the analysis
and its cost.

In our implementation, we use static type information to infer, statically, is a condition
\<@MustRedefineHashCode> or \<@MustRedefineHashCodeOrToString> holds. If the static type
$\tau$ of a value is a class that redefines \<Object.hashCode()> or \<Object.toString()>,
the same must hold for the dynamic type $\tau'$ of the value, that can only be an
instance of $\tau$. Hence the run-time condition must hold, always.
This follows from the fact that Java and Java bytecode
are strongly-typed. Otherwise, the \<verifier> method is added for that condition.
For \<@MustBeFalse>, our implementation looks, intra-procedurally, for
all producers of the annotated value.
If these are always the literal \<false>, then the condition
must hold. If, instead, at least one producer is the literal \<true> or a complex expression,
then the static analysis gives up and the \<verifier> method is added for that condition.
Albeit simple, these static analyses discharge more than half of the proof-obligations
in our test smart contracts.
