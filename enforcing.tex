\section{Enforcing Run-Time Conditions for Determinism}\label{sec:enforcing}

Sec.~\ref{sec:white_listing} shows that a deterministic fragment of the Java library
can specify run-time conditions on the values of the receiver or
parameters of its methods. A blockchain node must enforce that such conditions hold
at run time for the smart contracts that it executes. Hence each condition
is a proof-obligation that must be discharged: if this is not possible, the smart contract
cannot be executed or, at least, its execution must be aborted. This section shows how
this is possible.

Very likely, a blockchain node receives the smart contract already compiled in Java bytecode.
The idea is hence to instrument such bytecode, only the first time it is installed in blockchain,
with extra checks that verify the run-time conditions.
To make the technique more accessible to the reader, this section presents
the instrumentation at source-code level, but it actually works at bytecode level.

Assume that a blockchain node verifies that smart contracts obey to the deterministic
fragment in Figs.~\ref{fig:white_listed_Object}, \ref{fig:white_listed_Collection},
\ref{fig:white_listed_Set}, \ref{fig:white_listed_List},
\ref{fig:white_listed_HashSet} and~\ref{fig:white_listed_ArrayList}.
Assume that a user installs in blockchain a smart contract whose
code contains \<collection.remove(element)>, whose static target is
\<Collection$\text{<}$E$\text{>}$.remove(Object o)>.
The node spots this syntactically.\footnote{The Java bytecode of the
  smart contract will
  contain an instruction \<invokeinterface java.util.Collection.remove(Object):boolean>,
  or a similar one for a subtype of \<Collection>.}
The node consults its white-listed fragment and recognizes the call as
white-listed, but having a run-time constraint \<@MustRedefineHashCode> on \<o>
(Fig.~\ref{fig:white_listed_Collection}). Hence, it
adds a brand new method to the code of the smart contract:

{\small\begin{verbatim}
private static boolean verifier_0(Collection<E> receiver, Object par_0) {
  Support.mustRedefineHashCode(par_0);
  return receiver.remove(par_0);
}
\end{verbatim}}

\noindent
and replaces \<collection.remove(element)> with \<verifier\_0(collection, element)>.
Whenever that code is executed,
\<Support.mustRedefineHashCode(par\_0)> checks that the actual argument
passed to \<remove(Object o)> redefines \<hashCode()>. The node includes a
\<Support> class that uses Java reflection to that purpose:

{\small\begin{verbatim}
class Support {
  public static void mustRedefineHashCode(Object value) {
    if (value != null)
      if (Stream.of(value.getClass().getMethods())
          .filter(method -> !Modifier.isAbstract(method.getModifiers())
                         && Modifier.isPublic(method.getModifiers())
                         && method.getDeclaringClass() != Object.class)
          .map(Method::getName)
          .noneMatch("hashCode"::equals)) {
        // abort the current transaction and undo all its side-effects
      }
  }
}
\end{verbatim}}

\noindent
The code above\footnote{This is code in the blockchain node, not in a smart contract:
  any method can be used here; there is no white-listing notion for it.}
checks if the value is non-\<null> and has no method
named \<hashCode>
(possibly inherited) that is public, non-abstract and not declared in \<Object>.
If that is the case, then the value does not redefine \<hashCode()> from \<Object>
and the transaction gets aborted.

For another example, assume that the smart contract calls
\<x.toString()>, with static target \<Object.toString()>.
The blockchain node spots this syntactically,
consults its white-listed fragment and recognizes the call as
white-listed, but having a run-time constraint \<@MustRedefineHashCodeOrToString> on
\<x> (Fig.~\ref{fig:white_listed_Object}).
Consequently, it adds a brand new method to the code of the smart contract:

{\small\begin{verbatim}
private static verifier_1(Object receiver) {
  Support.mustRedefineHashCodeOrToString(receiver);
  return receiver.toString();
}
\end{verbatim}}

\noindent
The node replaces \<x.toString()> with \<verifier\_1(x)>.
The check is performed by \<Support.mustRedefineHashCodeOrToString(receiver)> this time,
defined similarly to the previous example.

Assume that the smart contract contains a static call
\<StreamSupport.stream(s, p)>, whose static target is
\<StreamSupport.stream(Spliterator$\text{<}$T$\text{>}$ s, boolean p)>,
and that the white-listed fragment of the blockchain node allows that signature,
but has a run-time condition on \<p> that avoids the creation of parallel streams:
\<StreamSupport.stream(Spliterator$\text{<}$T$\text{>}$ s, @MustBeFalse boolean p)>.
The node adds a brand new method to the smart contract:

{\small\begin{verbatim}
private static Stream<T> verifier_2(Spliterator<T> par_0, boolean par_1) {
  Support.mustBeFalse(par_1);
  return StreamSupport.stream(par_0, par_1);
}
\end{verbatim}}

\noindent
Then it replaces \<StreamSupport.stream(s, p)> with \<verifier\_2(s, p)>.
Method \<Support.mustBeFalse(value)> is defined in class \<Support> as:

{\small\begin{verbatim}
public static void mustBeFalse(boolean value) {
  if (value) {
    // abort the current transaction and undo all its side-effects
  }
}
\end{verbatim}}

The name of the verification methods (\<verifier\_0>, \<verifier\_1> and so on)
must be chosen in such a way to avoid name clashes with already existing methods.
Moreover, if a call is repeated
in the smart contract, it is more efficient to share the same verifier for all
its occurrences and keep the class file smaller.

We have implemented this technique at bytecode level, by using the BCEL
library for bytecode manipulation~\cite{bcel}. The cost of instrumentation never exceeds one
second on our machine.

\subsection{Static vs.\ Dynamic}\label{subsec:static_vs_dynamic}

The instrumentation technique described above adds dynamic checks on run-time values, to see
if these satisfy the conditions required by a white-listed fragment.
Hence, checks are performed repeatedly, every time an annotated white-listed method
is executed. This can incur in a performance penalty. It would be better
to check if a run-time condition holds, definitely, when smart contracts are installed
in blockchain.
This can be done with static analysis~\cite{NielsonNH99}, a technique that infers
properties of programs, before they are actually run. Since the verification of
non-trivial run-time program properties is in general undecidable~\cite{Rice53},
static analysis provides a definite answer
only in some cases. Hence, a blockchain node can use static analysis to discharge
the proof-obligations due to run-time conditions on white-listed methods. If it
succeeds with a definite answer, stating that a given condition definitely holds,
the blockchain node needn't generate any \<verifier> method for that condition. Otherwise, it
generates the \<verifier> method, as last resort.

Static analysis can be more or less aggressive.
More aggressive static analyses discharge more proof-obligations statically,
which is desirable since the smart contract's code will check less
conditions at run-time. However, aggressive analyses are typically more expensive
(although they are executed only once, when the smart contract is installed in
blockchain). In practice, a good trade-off should be found between the power of the analysis
and its cost.

Our implementation uses static type information to infer, statically, if a condition
\<@MustRedefineHashCode> or \<@MustRedefineHashCodeOrToString> holds for a variable \<v>.
If the static type
$\tau$ of \<v> is a class that redefines \<Object.hashCode()> or \<Object.toString()>,
the same must hold for the dynamic type $\tau'$ of \<v>, that can only be an
instance of $\tau$. Hence the run-time condition must hold, always.
This follows from the fact that Java and Java bytecode
are strongly-typed. Otherwise, the \<verifier> method is added for that condition.
For \<@MustBeFalse>, our implementation looks, intra-procedurally, for
the producers of the annotated value.
If these are always the literal \<false>, then the condition holds.
If, instead, at least one producer is the literal \<true> or a complex expression,
then the static analysis gives up and the \<verifier> method is added.
Albeit simple, these static analyses discharge more than half of the proof-obligations
in our test smart contracts.
