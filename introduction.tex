\section{Introduction}\label{sec:introduction}

Smart contracts are programs that specify the effects of running blockchain transactions.
They are written in specialized programming languages, that take into account
the fact that smart contracts operate on data kept in blockchain and must
support some special concepts, such as the access to the caller of a transaction
and the payment of code execution through \emph{gas}.
Such concepts are not natively available
in traditional programming languages.
The same Bitcoin bytecode~\cite{Antonopoulos17,Nakamoto08}
can be seen as a language for programming smart contracts,
although non-Turing equivalent and mostly limited to coin transfers. The more
powerful Solidity language~\cite{AntonopoulosW18},
compiled into Ethereum bytecode, allows one to code
more involved smart contracts, in an imperative high-level language, and is
one of the main reasons behind the success of the Ethereum blockchain.

Recently, there have been efforts towards the use of traditional
high-level languages for writing smart contracts. In particular, Java has
been chosen since it is a well-known programming language,
with modern features such as generics, inner classes, lambda
expressions and streams. Technically, Java has
a large and powerful toolbelt and an active community.
These efforts~\cite{aion,aion_example_contract,neo,neo_contract}
[extra reference removed for blind review]
typically allow programmers to write code in a limited version of Java,
with extra methods and classes to implement contracts, refer to their
callers and implement payable methods.

One of the most compelling reasons for writing smart contracts
in a mainstream language such as Java is that it comes with a large
library, that provides general solutions for typical programming problems.
Many programmers are familiar with this library and appreciate the possibility
of using the same also for developing smart contracts. This reduces
development time and errors, since the library has been widely tested
in the last decades and its semantics is well-known. There is, however, a big
issue here. Namely, the support library of Java is non-deterministic, in general,
while smart contracts must be deterministic, or otherwise blockchain consensus
cannot be reached.

Non-determinism is obvious for library classes and methods that support, explicitly,
parallel processing or random computations. But the main problem is that
also some library features, that are explicitly sequential, might lead to
non-deterministic results. That is, different runs of the same code, with the
same input, might lead to different results, even on the same machine.
This is well-known to Java programmers and has been at the origin of subtle
bugs also in traditional software. In the case of smart contracts, however,
this situation cannot be tolerated.

The contributions of this paper are the discussion of the kind of determinism
needed for smart contracts; a way for specifying deterministic fragments
of the Java library; and a technique for
enforcing some conditions needed for determinism, statically or dynamically.
We have implemented this technique, that is currently part of the verification
layer for smart contracts of the [reference removed for blind review] blockchain.

This work is organized as follows.
Sec.~\ref{sec:determinism} discusses the kind of determinism expected for Java smart contracts,
with specific examples of methods from the Java library.
Sec.~\ref{sec:white_listing} presents a technique for specifying \emph{white-listed} fragments of the Java library,
that is, subsets of the library that are allowed in smart contracts.
Sec.~\ref{sec:proof_obligations} shows that
some fragments are deterministic only under specific conditions on the way their methods
are called.
Sec.~\ref{sec:enforcing} provides a technique for enforcing such conditions, dynamically
or statically, based on bytecode instrumentation.

This paper is \emph{not} about Java smart contracts themselves. The interested reader
is referred to the references provided above. Hence, this paper does not tackle
the specific syntax, methods and technology needed for writing smart contracts in Java.
Therefore, examples are presented in an abstract way, unrelated to any specific
Java dialect for smart contracts or blockchain.
