\section{Introduction}\label{sec:introduction}

Smart contracts are programs that specify the effects of running blockchain transactions.
They are written in specialized programming languages, that take into account
the fact that smart contracts operate on data kept in blockchain. They must
support some special concepts, such as the access to the caller of a transaction,
monetary transfers between contracts
and payment of code execution through \emph{gas}.
Such concepts are not natively available
in traditional programming languages.
Instead, the Bitcoin bytecode~\cite{Antonopoulos17,Nakamoto08}
can be seen as a language for programming smart contracts,
although non-Turing equivalent and mostly limited to coin transfers. The more
powerful Solidity language~\cite{AntonopoulosW18},
compiled into Ethereum bytecode, allows one to code
complex smart contracts, in an imperative high-level language, and is
one of the main reasons behind the success of the Ethereum blockchain.

Recently, there have been efforts towards the use of traditional
high-level languages for writing smart contracts.
A notable example is the Hyperledger Fabric blockchain~\cite{AndroulakiBBCCC18,Vukolic17}, that allows one
to write smart contracts in Java, among other languages. Citing from~\cite{AndroulakiBBCCC18},
``blockchain domain-specific languages are difficult to design for the implementer
and require additional learning by the programmer. Writing smart contracts
in a general-purpose language (\emph{e.g.}, Go, Java, C/C++) instead
appears more attractive and accelerates the adoption of blockchain solutions''.
In particular, Java is a well-known programming language,
with modern features such as generics, inner classes, lambda
expressions and lazy streams. Java has
a large and powerful toolbelt and an active community.
Also other blockchains~\cite{aion,aion_example_contract,neo,neo_contract,Spoto19}
typically allow programmers to write code in a limited subset of Java
and of its support library,
with extra methods and classes to implement contracts, refer to their
callers and implement monetary transfers.

One of the most compelling reasons for writing smart contracts
in a mainstream language such as Java is that it comes with a large
support library, that provides general solutions to typical programming problems.
Many programmers are familiar with that library and appreciate the possibility
of using it also for developing smart contracts. This reduces
development time and errors, since the library has been widely tested
in the last decades and its semantics is well-known. There is, however, a big
issue here. Namely, the support library of Java is non-deterministic, in general.
For most blockchains, non-determinism leads to a fork of the network, since
consensus cannot be reached. Hyperledger Fabric allows instead non-determinism,
in the sense that code executions, if non-deterministic, get rejected~\cite{Vukolic17}.
Hence, also in this case, programmers should avoid non-determinism, if they want their code to be
run in blockchain.

Non-determinism is obvious for library classes and methods that support, explicitly,
parallel or random computations. But the real problem is that
also some library parts, that are explicitly sequential, might lead to
non-deterministic results.
This is well-known to Java programmers and has been at the origin of subtle
bugs also in traditional software. For smart contracts, however,
this situation cannot be tolerated: the execution of the same code, from the same state,
\emph{must} lead to the same result in any two distinct blockchain nodes.

A solution could be to write a specific Java library, whose
methods are made deterministic. But this is far from simple, since the Java library is huge
and some modifications would interfere with very low-level aspects of the language, such as
its memory allocation strategy and its garbage collectors.
The process should be repated for each new version of the library.
Moreover, programmers should be adviced to use a library with a different semantics than the usual one.
Finally, one should be sure to have fixed \emph{all} possible sources of non-determinism in the
(immense) Java library.
Instead, this paper advocates the use of a standard, fixed Java library, restricted to a white-listed
fragment and with the addition of a verification layer that enforces some run-time conditions.
It must be ensured that this fragment is deterministic, which is typically small (but still
large if compared to, say, Solidity, that has \emph{no} support library). One needn't prove
to have caught every single potential case of non-determinism in the library. One only needs to
prove that the white-listed sandbox is safe.

Namely, the contributions of this paper are a discussion of the (non-)determinism
of the Java library methods; a way for specifying deterministic fragments
of that library; and a technique for
enforcing some run-time conditions needed for determinism, statically or dynamically.
We have implemented this technique, that is currently part of the verification
layer for Java smart contracts of the Takamaka blockchain.
The deterministic fragment has been specified manually, since there is
currently no automatic way of proving that a method is deterministic.
The Takamaka blockchain verifies and then instruments the code of the smart contracts, that gets
then installed, in instrumented form, in blockchain~\cite{Spoto19}. Later, transactions execute the
instrumented code, not the original one. All nodes perform verification and instrumentation
and must agree on the result. It is not possible that an attacker modifies the instrumented program
or its execution semantics after it has been installed in blockchain.

This work is organized as follows.
Sec.~\ref{sec:determinism} discusses the (non-)determinism featured by some
examples of Java library methods.
Sec.~\ref{sec:white_listing} defines the notion of \emph{deterministic white-listed fragment} of the Java library,
that is, a deterministic subset of the library that can be used for writing smart contracts.
Its definition can use run-time conditions on the way its methods are called.
Sec.~\ref{sec:enforcing} provides a technique for enforcing such conditions, dynamically
or statically, through bytecode instrumentation.

This paper is \emph{not} about Java smart contracts themselves. The interested reader
is referred to the references provided above and, in particular, to ~\cite{Spoto19}.
Hence, this paper does not tackle
the specific syntax, methods and technology needed for writing smart contracts in Java.
Examples are presented in an abstract way, unrelated to any specific
Java dialect for smart contracts or any specific blockchain.
