\section{White-Listed Fragments of the Java Library}\label{sec:white_listing}

\newcommand{\wl}{\mathit{WL}}

Sec.~\ref{sec:determinism} has shown that some methods of the Java library can be used
in smart contracts, at least if a specific version of the library is fixed and some
run-time conditions are enforced. Such methods are called \emph{white-listed}
(Fig.~\ref{fig:determinism}).

\begin{definition}\label{def:white-listing}
  A \emph{white-listed fragment} $\wl$ is a set of method signatures (constructors are considered
  methods named as their defining class), with associated run-time conditions.
\end{definition}
%
A white-listed fragment must be part of the
consensus rules: each node verifies that the methods used in smart contracts are
in the fragmemt and otherwise rejects the installation of the smart contract
in blockchain.
%
\begin{definition}\label{def:obeys}
  A program $P$ \emph{obeys} a white-listed fragment $\wl$ if and only if
  \begin{enumerate}
    \item every method call
      in $P$ has a static target that is either in $\wl$ or redefines a signature in $\wl$
      (syntactical check); and
    \item in every execution of $P$, the run-time conditions in $\wl$ hold (semantical check).
  \end{enumerate}
\end{definition}
%
\begin{definition}\label{def:deterministic}
  Given a Java library version $V$, a white-listed fragment $\wl$ is
  \emph{deterministic for $V$}
  if and only if any Java program that obeys $\wl$
  is deterministic, when executed over $V$.
\end{definition}

A very simple example of white-listed fragment is
$\wl_1=\emptyset$. It is deterministic for every Java library version.
Namely, a program that obeys $\wl_1$ cannot call any library method or constructor
(condition 1 of Def.~\ref{def:obeys}).
Since Java classes must, at least, call the constructor of their superclass, it follows
that no Java program can obey $\wl_1$, that is hence vacuously deterministic.

Another white-listed fragment is $\wl_2=\{\<Object()>\}$. It contains
just the constructor of class \<Object>. This time, it is possible to write programs $P$
that obey $\wl_2$, whose classes extend \<Object> and whose constructors call \<Object()>.
But no other library methods and contructors can be called, which is an irrealistic
constraint.

A white-listed fragment that allows, at least, simple string manipulations is
$\wl_3=\{\<Object()>,\<String.concat(String other)>,\<String.length()>\}$. It allows one
to write Java programs whose classes extend \<Object> and whose code performs computations
such as \<"hello".concat(s).length()>, where \<s> is a string.

Up to now, we have not used run-time conditions in white-listed fragments.
In order to specify such conditions, it is possible to use Java annotations on
method signatures. An annotation can be applied to a formal parameter, meaning that
the condition must hold for the corresponding actual parameter; or to a non-static method
itself, meaning that the condition must hold for the receiver of the method.
Let us introduce for instance the following annotations:
%
\begin{description}
\item[\<@MustRedefineHashCode>:] the annotated value is \<null> or belongs to a class that redefines
  \<Object.hashCode()>;
\item[\<@MustRedefineHashCodeOrToString>:] the annotated value is \<null> or belongs to a class that redefines
  \<Object.hashCode()> or \<Object.toString()> (or both);
\item[\<@MustBeFalse>:] the annotated value is \<false>.
\end{description}
%
With these annotations, it is possible to define the white-listed fragment:
%
\[
\wl_4=\left\{\begin{array}{c}
\mbox{\<Object()>},\\
\mbox{\<@MustRedefineHashCodeOrToString Object.toString()>},\\
\mbox{\<HashSet$\text{<}$E$\text{>}$()>},\\
\mbox{\<Collection$\text{<}$E$\text{>}$.add(@MustRedefineHashCode E e)>}
\end{array}\right\}
\]
%
that constrains \<Object.toString()> to be called on values that redefine
at least one of \<hashCode()> and \<toString()>, and
\<Collection$\text{<}$E$\text{>}$.add(E e)> to be called
with a parameter that redefines \<hashCode()>. $\wl_4$ is deterministic
for any given Java library version, thanks
to such constraints. For instance, the following code is deterministic
on any Java library: it creates a hashset and populates it with a
\<String>, a \<java.math.BigInteger> and an empty \<HashSet>. All these three
classes redefine method \<hashCode()> hence the constraint on \<add()> holds.
At the end the following code calls \<toString()> on the set of three elements.
The class \<HashSet> of \<set> redefines \<toString()>, hence the constraint
on \<toString()> holds:
%
\begin{verbatim}
Set<Object> set = new HashSet<>();
set.add("hello");
set.add(BigInteger.ONE);
set.add(new HashSet<String>());
String s = set.toString();
\end{verbatim}
%
Variable \<s> above, on the library implementation OpenJDK 8, always contains the string
\<"[[], 1, hello]">. Other versions of the library might compute different strings but,
once a library version is fixed, always the same string is computed.
The reason of this determinism is that the shape of the buckets of the hashset is fixed
since the \<hashCode()> of its elements is redefined in a deterministic way in
\<String>, \<BigInteger> and \<HashSet>. Moreover, \<toString> on \<HashSet> has been
redefined in a way that iterates on the elements of the hashset and concatenates
their \<toString()>. Since the \<hashCode()> of the elements has been redefined,
this does not use the pointer address of the elements.

The explication above about the determinism of the code follows from
a manual investigation of the source code of the library. It is not automated. What can
be automated is, instead, the verification that the code obeys to a given $\wl$.
Namely, condition 1 of Def.~\ref{def:obeys} can be checked
in $O(|P|\cdot h\cdot\log_2|\wl|)$ time, where $|P|$ is the size of the program $P$ to check,
$h$ is the maximal height of the class
hierarchy and $|\wl|$ is the size of $\wl$.
Namely, for the static target of every call in $P$, it is enough
to follow the class hierarchy upwards, while checking if the method is in $\wl$. If a total
order is defined on method signatures, this last check can be done through binary search,
with logarithmic complexity. Condition 2 of Def.~\ref{def:obeys} is more tricky and
Sec.~\ref{sec:enforcing} will consider how it can be enforced.

A white-listed fragment must be specified in a way that a machine can easily read.
Since it is a set of method and constructor signatures, it is possible to provide it
as a set of Java abstract classes and interfaces. For each library class \<C> that defines some
methods to white-list, one writes an abstract class \<whitelisted.C>;
for each interface \<I>, one write an interface \<whitelisted.I>. That is, one defines,
in package \<whitelisted>, some \emph{mirrors} declaring the white-listed methods or
constructors only, with their annotations, if any.
The advantage of using such mirrors is that they can be written by copying and pasting
signatures from the source code of the mirrored classes. Moreover, they can be compiled,
which helps spotting typos. Finally, a blockchain node can query such classes by reflection,
which is both simple and efficient, compared for instance with querying textual or XML
specifications. Of course, the same mirrored classes must be part of the consensus rules.

\begin{figure}[t]
\begin{verbatim}
public abstract class whitelisted.java.lang.Object {
  public Object() {}
  public abstract boolean equals(java.lang.Object other);
  public abstract @MustRedefineHashCodeOrToString java.lang.String toString();
  public abstract @MustRedefineHashCode int hashCode();
}
\end{verbatim}
\caption{A specification of the white-listed methods of class \<Object>.}
\label{fig:white_listed_Object}
\end{figure}

\begin{figure}[t]
\begin{verbatim}
public interface whitelisted.java.util.Collection<E> {
  int size();
  boolean isEmpty();
  java.lang.Object[] toArray();
  <T> T[] toArray(T[] a);
  <T> T[] toArray(java.util.function.IntFunction<T[]> generator);
  boolean add(@MustRedefineHashCode E e);
  boolean contains(@MustRedefineHashCode java.lang.Object o);
  boolean remove(@MustRedefineHashCode java.lang.Object o);
  boolean containsAll(java.util.Collection<?> c);
  boolean addAll(java.util.Collection<? extends E> c);
  boolean removeAll(java.util.Collection<?> c);
  boolean removeIf(java.util.function.Predicate<? super E> filter);
  boolean retainAll(java.util.Collection<?> c);
  void clear();
  java.util.stream.Stream<E> stream();
  java.lang.Iterator<E> iterator();
}
\end{verbatim}
\caption{A specification of the white-listed methods of interface \<Collection>.}
\label{fig:white_listed_Collection}
\end{figure}

\begin{figure}[t]
\begin{verbatim}
public interface whitelisted.java.util.Set<E> {
  boolean containsAll(java.util.Collection<?> c);
  boolean addAll(java.util.Collection<? extends E> c);
  boolean retainAll(java.util.Collection<?> c);
  boolean removeAll(java.util.Collection<?> c);
}
\end{verbatim}
\caption{A specification of the white-listed methods of interface \<Set>.}
\label{fig:white_listed_Set}
\end{figure}

\begin{figure}[t]
\begin{verbatim}
public interface whitelisted.java.util.List<E> {
  E get(int index);
  E remove(int index);
  boolean remove(java.lang.Object o);
  boolean contains(java.lang.Object o);
  void sort(java.util.Comparator<? super E> c);
  E set(int index, @MustRedefineHashCode E element);
  void add(int index, @MustRedefineHashCode E element);
  int indexOf(java.lang.Object o);
  int lastIndexOf(java.lang.Object o);
  java.util.ListIterator<E> listIterator();
  java.util.ListIterator<E> listIterator(int index);
  java.util.List<E> subList(int fromIndex, int toIndex);
  java.util.Spliterator<E> spliterator();
}
\end{verbatim}
\caption{A specification of the white-listed methods of interface \<List>.}
\label{fig:white_listed_List}
\end{figure}

\begin{figure}
\begin{verbatim}
public class whitelisted.java.util.HashSet<E> {
  public HashSet() {}
  public HashSet(java.util.Collection<? extends E> c) {}
  public HashSet(int initialCapacity, float loadFactor) {}
  public HashSet(int initialCapacity) {}
}
\end{verbatim}
\caption{A specification of the white-listed methods of class \<HashSet>.}
\label{fig:white_listed_HashSet}
\end{figure}

\begin{figure}
\begin{verbatim}
public abstract class whitelisted.java.util.ArrayList<E> {
  public ArrayList() {}
  public ArrayList(int size) {}
  public ArrayList(java.util.Collection<? extends E> c) {}
  public abstract void trimToSize();
  public abstract void ensureCapacity(int minCapacity);
}
\end{verbatim}
\caption{A specification of the white-listed methods of class \<ArrayList>.}
\label{fig:white_listed_ArrayList}
\end{figure}

For instance, Figs.~\ref{fig:white_listed_Object}, \ref{fig:white_listed_Collection},
\ref{fig:white_listed_Set}, \ref{fig:white_listed_List},
\ref{fig:white_listed_HashSet} and \ref{fig:white_listed_ArrayList}
specify a white-listed portion of \<Object>,
\<Collection>, \<Set>, \<List>, \<HashSet> and \<ArrayList>,
respectively.\footnote{Method and constructor signatures are copy and paste from the
Java library source code. For the use of generics, wildcards and
\<Object> in these signatures, we refer to~\cite{NaftalinW06}.}
This fragment is deterministic for a given fixed version of the Java library.
Thanks to its annotations, this fragment guarantees that elements in collections
(hence also in sets or lists) redefine \<hashCode()>, which makes iterators
on collections, streams derived from collections and \<toString()> on collections
deterministic. The latter can be called on collections since they redefine it,
hence satisfying the constraint in Fig.~\ref{fig:white_listed_Object}.
Method \<contains(Object o)> in \<Collection> (Fig.~\ref{fig:white_listed_Collection})
requires \<o> to redefine \<hashCode()>,
or otherwise, for hashsets, the bucket where \<o> is looked for might be different
for different runs, with subsequent non-deterministic behavior.
That constraint has been lifted for \<contains(Object o)> in \<List>
(Fig.~\ref{fig:white_listed_List}), since its implementation, for lists,
scans the list from its head,
looking for an \<equals()> element, with deterministic behavior,
regardless of \<o> having redefined \<hashCode()>. This is an application
of the Liskov substitution principle~\cite{LiskovW94}:
white-listing constraints can be weakened in subclasses,
but not strengthened. The same applies to method \<remove(Object o)>, passing from
\<Collection> to \<List>.

It is interesting to observe that there is not a single largest deterministic fragment
for a given set of classes and interfaces. For instance, 
there is another deterministic fragment for the same classes considered in
Figs.~\ref{fig:white_listed_Object}, \ref{fig:white_listed_Collection},
\ref{fig:white_listed_Set}, \ref{fig:white_listed_List},
\ref{fig:white_listed_HashSet} and \ref{fig:white_listed_ArrayList}, identical
to those figures but allowing any elements in lists, possibly not redefining
their \<hashCode()> (hence more permissive);
forbidding \<Object.toString()> and \<Object.hashCode()> (Fig.~\ref{fig:white_listed_Object}),
that would be non-deterministic on lists now (hence
more restrictive); and forbidding the conversion constructor
\<HashSet(Collection$\text{<}$? extends E$\text{>}$ c)>
(Fig.~\ref{fig:white_listed_HashSet}), that would otherwise allow a hashset to be
built from a list and hence contain elements whose \<hashCode()> has not been redefined,
with consequent non-determinism (hence more restrictive). The choice between alternative
deterministic fragments for a given set of classes is more a question of personal taste.
One should choose the one that allows more methods of frequent use. In this example,
forbidding \<Object.toString()> and \<Object.hashCode()> would hardly be acceptable in practice.
In principle, blockchain nodes could know about more deterministic fragments and check
if a smart contract obeys at least one of them, hence allowing more code, in general.
In practice, the extra cost of using more fragments might not justify the effort.
